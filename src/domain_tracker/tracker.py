from tracker_utils import *
from tracker_contours import *
from tracker_dilate import *
from tracker_properties import *
from tracker_mag import *
from tracker_plotting import *
import itertools

"""
%%%%%%%%%%%%%%%%%%%%%%%
-----------------------
     Domain Class
-----------------------
%%%%%%%%%%%%%%%%%%%%%%%
"""
class Domain:
    def __init__(self, id, frame, shape):
        self.id = id
        self.global_id = None
        self.family_ids = []
        self.parent_ids = []
        self.child_ids = []
        self.frame = frame
        self.shape = shape
        self.proj = None  # dictionary from projection layer
        self.layers = {}  # z-layer: domain_z data
        self.core = np.zeros(shape, dtype=bool)
        self.shell = np.zeros(shape, dtype=bool)
        self.mask = np.zeros(shape, dtype=bool)
        self.bps = []
        self.bls = {} # generated from bps data by group_bps
        self.gammas = []
        self.ws = []
        self.properties = {} # generated by get_properties
        self.energy = {}

    def get_projection(self, proj_dict):
        self.proj = proj_dict

    def add_layer(self, z, key_z, domain_z):
        # Merge layer bps, mask, and shell to Domain
        self.core[:,:,z] |= domain_z['core']
        self.shell[:,:,z] |= domain_z['shell']
        self.mask[:,:,z] |= domain_z['mask']
        self.bps += domain_z['bps']
        self.gammas.append(domain_z['gammas'])
        self.ws.append(domain_z['w'])
        # Append layer dict to Domain
        del domain_z['core']
        del domain_z['shell']
        del domain_z['mask']
        del domain_z['bps']
        del domain_z['gammas']
        del domain_z['w']
        self.layers[z] = {}
        self.layers[z][key_z] = domain_z

    def get_properties(self):
        self.properties = get_domain_properties(self.layers,self.shape)

    # WIP: add z dependent energy list (done?)
    def add_energy(self, energy, energy_label):
        core = self.unpack_mask(core=True)
        shell = self.unpack_mask(shell=True)
        mask = self.unpack_mask()
        self.energy[energy_label+'_core'] = sum(energy[core])
        self.energy[energy_label+'_dw'] = sum(energy[shell])
        self.energy[energy_label] = sum(energy[mask])
        self.energy[energy_label+'_core_z'] = []
        self.energy[energy_label+'_dw_z'] = []
        self.energy[energy_label+'_z'] = []
        for z in np.arange(self.shape[2]):
            self.energy[energy_label+'_core_z'].append(sum(energy[core[:,:,z]]))
            self.energy[energy_label+'_dw_z'].append(sum(energy[shell[:,:,z]]))
            self.energy[energy_label+'_z'].append(sum(energy[mask[:,:,z]]))

    def group_bps(self):
        self.bls = find_bls(self.bps, distance_threshold=-1)

    def pack_masks(self):
        if self.proj:
            self.proj['core'] = pack_mask(self.proj['core'])
        self.core = pack_mask(self.core)
        self.shell = pack_mask(self.shell)
        self.mask = pack_mask(self.mask)

    def unpack_mask(self, proj=False, shell=False, core=False):
        if proj and self.proj:
            return unpack_mask(self.proj['core'], self.shape[:2])
        elif shell:
            return unpack_mask(self.shell, self.shape)
        elif core:
            return unpack_mask(self.core, self.shape)
        else:
            return unpack_mask(self.mask, self.shape)

    def intersection(self, other, proj=True):
        if self.shape != other.shape:
            return 0.0
        mask = self.unpack_mask(proj=proj)
        other_mask = other.unpack_mask(proj=proj)
        return np.logical_and(mask, other_mask).sum()
    
    def union(self, other, proj=True):
        if self.shape != other.shape:
            return 0.0
        mask = self.unpack_mask(proj=proj)
        other_mask = other.unpack_mask(proj=proj)
        return np.logical_or(mask, other_mask).sum()
    
    def iou(self, other, proj=True):
        intersection = self.intersection(other,proj)
        union = self.union(other,proj)
        return intersection / union if union > 0 else 0.0

    def distance_to(self, other):
        if self.properties:
            center0 = self.properties['center']
            center1 = other.properties['center']
            return pbc_min_dist(center0, center1, self.shape)
        else:
            raise ValueError("Domain properties have not been initialized!")

class DomainChron:
    def __init__(self, domain):
        self.family_ids = domain.family_ids
        self.parent_ids = domain.parent_ids
        self.child_ids = domain.child_ids
        self.shape = domain.shape
        self.frames = [domain.frame]
        self.tags = []
        self.type = []
        self.is_stripe = []
        """
        self.proj = {}
        for key, value in domain.proj.items():
            self.proj[key] = [value]
        """
        self.core = [domain.core]
        self.shell = [domain.shell]
        self.mask = [domain.mask]
        self.bps = [domain.bps]
        self.bls = [domain.bls]
        self.bl_orientations = []
        self.gammas = [domain.gammas]
        self.ws = [domain.ws]
        self.properties = {}
        for key, value in domain.properties.items():
            self.properties[key] = [value]
        self.energy = {}
        for key, value in domain.energy.items():
            self.energy[key] = [value]

    def add_domain(self, domain):
        self.child_ids.extend(domain.child_ids)
        self.frames.append(domain.frame)
        """
        for key, value in domain.proj.items():
            self.proj[key].append(value)
        """
        self.core.append(domain.core)
        self.shell.append(domain.shell)
        self.mask.append(domain.mask)
        self.bps.append(domain.bps)
        self.bls.append(domain.bls)
        self.gammas.append(domain.gammas)
        self.ws.append(domain.ws)
        for key, value in domain.properties.items():
            self.properties[key].append(value)
        for key, value in domain.energy.items():
            self.energy[key].append(value)

    def unpack_mask(self, frame, shell=False, core=False):
        if shell:
            return unpack_mask(self.shell[frame], self.shape)
        elif core:
            return unpack_mask(self.core[frame], self.shape)
        else:
            return unpack_mask(self.mask[frame], self.shape)
    
    def track_bl_orientation(self, bl_height_cutoff = 10):
        self.bl_orientations = []
        for bls in self.bls:
            if len(bls) == 0:
                self.bl_orientations.append(np.nan)
                continue

            max_points = {'in': (0,0), 'out': (0,0)}
            max_ranges = {'in': -float('inf'), 'out': -float('inf')}

            for bl in bls.values():
                t = bl['type']
                z_min, z_max = bl['z_extent']
                z_range = z_max - z_min
                if z_range > max_ranges[t]:
                    max_ranges[t] = z_range
                    max_points[t] = bl['position']

            if max_ranges['in'] < bl_height_cutoff or max_ranges['out'] < bl_height_cutoff:
                self.bl_orientations.append(np.nan)
                continue

            p1, p2 = max_points['in'], max_points['out']
            dx = p2[0] - p1[0]
            dy = p2[1] - p1[1]
            self.bl_orientations.append(np.arctan2(dy, dx))

    # WIP: need to add time frame dependent type designation
    def categorize_old(self, aspect_ratio_thresh = 4, bl_height_cutoff = 10):
        self.tags = []
        self.track_bl_orientation(bl_height_cutoff=bl_height_cutoff)
        frames_w_bls = sum(1 for sublist in self.bls if sublist)

        if frames_w_bls == 0:
            self.tags.append('Type I')
        if frames_w_bls > 0:
            N_sk_bot = []
            N_sk_mid = []
            N_sk_top = []
            for frame, bls in enumerate(self.bls):
                check_extent = False
                if len(self.child_ids) != 0:
                    self.tags.append('stripe')
                    break
                if len(bls) == 0:
                    N_sk_bot.append(1)
                    N_sk_mid.append(1)
                    N_sk_top.append(1)
                if len(bls) > 0:
                    N_sk_mid.append(0)
                    z_extents = [np.inf,-np.inf]
                    for bl in bls.values():
                        if bl['z_extent'][0] < z_extents[0]:
                            z_extents[0] = bl['z_extent'][0]
                        if bl['z_extent'][1] > z_extents[1]:
                            z_extents[1] = bl['z_extent'][1]
                    if z_extents[0] == 0:
                        N_sk_bot.append(0)
                    else:
                        check_extent = True
                    if z_extents[1] == self.shape[2]-1:
                        N_sk_top.append(0)
                    else:
                        check_extent = True
                    if check_extent:
                        shell = self.unpack_mask(frame, shell=True)
                        z_true = np.any(shell, axis=(0, 1))
                        z_indices = np.where(z_true)[0]
                        if abs(z_indices.min()-z_extents[0]) > 1:
                            N_sk_bot.append(1)
                        else:
                            N_sk_bot.append(0)
                        if abs(z_indices.max()-z_extents[1]) > 1:
                            N_sk_top.append(1)
                        else:
                            N_sk_top.append(0)

            frames_w_neel_caps = [x == 1 or y == 1 for x, y in zip(N_sk_bot, N_sk_top)]
            frames_as_achiral = N_sk_mid.count(0)
            if frames_as_achiral < len(self.frames) and 'stripe' not in self.tags:
                self.tags.append('Type II → Type I')
            if frames_as_achiral == len(self.frames) and 'stripe' not in self.tags:
                if sum(frames_w_neel_caps) > 0:
                    self.tags.append('Type II → Type III')
                else:
                    self.tags.append('Type II')
            rot = cumulative_rotation(self.bl_orientations)
            if np.any(rot, where = np.abs(rot)>np.pi/2) and 'stripe' not in self.tags:
                self.tags.append('rotates')

    # time dependent type categorization
    def categorize(self, thresh = 0.99):
        self.type = []
        self.is_stripe = []

        for ws in self.ws:
            if sum(np.abs(ws)) > thresh*self.shape[2]:
                self.type.append(1)
            elif sum(np.abs(ws)) < (1-thresh)*self.shape[2]:
                self.type.append(2)
            else:
                self.type.append(3)

            if len(self.child_ids) == 0:
                self.is_stripe.append(False)
            else:
                self.is_stripe.append(True)

"""
%%%%%%%%%%%%%%%%%%%%%%%
-----------------------
  Generator Functions
-----------------------
%%%%%%%%%%%%%%%%%%%%%%%
"""

def find_domains_frame(data, frame_idx, dil_dist=100, dil_mz_thresh=-0.5, polarity=1, debug=False):
    """
    Creates a dictionary of Domain3D objects with per-layer and projection data.
    """
    domains = {}
    data, _ = get_data(data)
    mx, my, mz = data['data']['m_x'], data['data']['m_y'], data['data']['m_z']
    arr_shape = (
        data['metadata']['xnodes'],
        data['metadata']['ynodes'],
        data['metadata']['znodes']
    )
    image_shape = arr_shape[:2]
    total_layers = arr_shape[2]

    # Step 1: Get projected domains and initialize Domains
    domains_proj = process_contours(mz, None, image_shape, dil_dist=dil_dist, dil_mz_thresh=dil_mz_thresh, polarity=polarity)
    theta, gamma = find_theta_gamma(mx, my, mz)

    for key, proj in domains_proj.items():
        d = Domain(key, frame_idx, arr_shape)
        d.get_projection(proj)
        domains[key] = d

    # Step 2: Layer-by-layer assignment
    for layer in range(total_layers):
        domains_z = process_contours(mz, layer, image_shape, theta_arr=theta, gamma_arr=gamma,
                                     dil_dist=dil_dist, dil_mz_thresh=dil_mz_thresh, polarity=polarity, debug=debug)
        for key_z, domain_z in domains_z.items():
            mask_z = domain_z['core']
            assigned = False
            for key, domain_proj in domains_proj.items():
                mask_proj = domain_proj['core']
                if mask_z.shape != mask_proj.shape:
                    raise ValueError(f"Shape mismatch at z={layer}, domain={key_z}, projected domain={key}")
                if np.any(np.logical_and(mask_z, mask_proj)):
                    domains[key].add_layer(layer, key_z, domain_z)
                    assigned = True
                    break
            if not assigned:
                raise RuntimeError(f"Unexpected: Domain {key_z} at z={layer} has no projection match.")

    # Step 3: Find additional properties and features
    n_bls = 0
    for domain in domains.values():
        domain.get_properties()
        domain.group_bps()
        n_bls += len(domain.bls)
        domain.pack_masks()
    print(f"Found {len(domains)} domains and {n_bls} Bloch lines")

    return domains

def find_domains(fnames, start_stop = None, energy=True, dil_dist=100, dil_mz_thresh=-0.5, debug=False):
    frames = {}
    # Group ovf files and determine range of indices
    m_index_map, prefix_index_map = build_prefix_index_dict(fnames)
    all_indices = set()
    all_indices.update(m_index_map.keys())
    sorted_indices = sorted(all_indices)
    # Handle flexible start_end logic
    if start_stop is None:
        start = sorted_indices[0]
        stop = sorted_indices[-1]
    else:
        start, stop = start_stop
        if start is None:
            start = sorted_indices[0]
        if stop is None:
            stop = sorted_indices[-1]
    indices = [i for i in sorted_indices if start <= i <= stop]
    total = len(indices)

    for idx in indices:
        print(f'Frame {idx} ({100*(idx-start+1)/total:.2f}%)')
        # Handle magnetization processing
        print('Finding domains and Bloch lines...')
        m_file = m_index_map[idx]
        domains = find_domains_frame(m_file, idx, dil_dist=dil_dist, dil_mz_thresh=dil_mz_thresh, debug=debug)
        frame = {'domains': domains}
        frames[idx] = frame

        # Handle energetics processing
        if energy:
            print('Calculating domain energy contributions...')
            for prefix in prefix_index_map:
                f = prefix_index_map[prefix].get(idx)
                if not f:
                    print(f'No file found for {prefix}, continuing...')
                    continue
                assign_edens(domains,f,prefix)
    return frames

"""
%%%%%%%%%%%%%%%%%%%%%%%
-----------------------
  Tracking Functions
-----------------------
%%%%%%%%%%%%%%%%%%%%%%%
"""

def match_domain(domain, candidates, iou_thresh=0.8, con_thresh=0.8):
    best_match = None
    best_score = 0
    children = []

    for candidate in candidates:
        iou = domain.iou(candidate, proj=True)
        com_dist = domain.distance_to(candidate)
        intersection = domain.intersection(candidate)
        if candidate.proj['properties']['area'] == 0:
            containment = 0
        else:
            containment = intersection / candidate.proj['properties']['area']  # portion of candidate covered by domain
        if domain.proj['properties']['area'] == 0:
            containment_rev = 0
        else:
            containment_rev = intersection / domain.proj['properties']['area'] # portion of domain covered by candidate

        # Check for best exact match
        if iou >= iou_thresh:
            score = iou / (1 + com_dist)
            if score > best_score:
                best_score = score
                best_match = candidate
        # Independent check for parent/child relationship
        elif containment >= con_thresh or containment_rev >= con_thresh:
            children.append(candidate)

    if not best_match and len(children) == 1:
        best_match = children[0]
        children = []

    return best_match, children

def track_domains_across_frames(frames, reset=False, iou_thresh=0.8, con_thresh=0.8):
    if reset:
        reset_tracking_across_frames(frames)

    next_global_id = itertools.count()
    next_family_id = itertools.count()
    sorted_frames = sorted(frames.keys())

    for i, t in enumerate(sorted_frames[:-1]):
        print(f"Tracking from frame {i} to {i+1}")
        curr_domains = list(frames[t]['domains'].values())
        next_domains = list(frames[sorted_frames[i + 1]]['domains'].values())
        for domain in curr_domains:
            if domain.global_id == None:
                domain.global_id = next(next_global_id)
            if domain.family_ids == []:
                domain.family_ids = [next(next_family_id)]

            best_match, children = match_domain(domain, next_domains, iou_thresh=iou_thresh, con_thresh=con_thresh)
            if best_match:
                best_match.global_id = domain.global_id
                best_match.family_ids.extend(domain.family_ids)
            if children:
                for child in children:
                    domain.child_ids.append(child.global_id)
                    child.parent_ids.append(domain.global_id)
                    child.family_ids.extend(domain.family_ids)
    return

def reset_tracking_across_frames(frames):
    for frame in frames.keys():
        for domain in frames[frame]['domains'].values():
            domain.global_id = None
            domain.family_ids = []
            domain.parent_ids = []
            domain.child_ids = []
    return

"""
%%%%%%%%%%%%%%%%%%%%%%%
-----------------------
  Energy Integration
-----------------------
%%%%%%%%%%%%%%%%%%%%%%%
"""
def assign_edens(domains, fname, edens_label):
    edens_data, _ = get_data(fname)
    edens_arr = edens_data['data'][edens_label].transpose((1,0,2))
    for domain in domains.values():
        domain.add_energy(edens_arr,edens_label)

"""
%%%%%%%%%%%%%%%%%%%%%%%
-----------------------
  Harvester Function
-----------------------
%%%%%%%%%%%%%%%%%%%%%%%
"""
def generate_domain_chronology(frames):
    domain_chronology = {}
    print('Generating grouped Domain dictionary')
    for i, frame in frames.items():
        print(f'Frame {i} ({100*(i-min(frames)+1)/len(frames):.2f}%)')
        for domain in frame['domains'].values():
            if domain.global_id in domain_chronology:
                domain_chronology[domain.global_id].add_domain(domain)
            else:
                domain_chronology[domain.global_id] = DomainChron(domain)
    return domain_chronology